#include <bitset>

#include <triqs/operators/many_body_operator.hpp>

#include <triqs/hilbert_space/fundamental_operator_set.hpp>
#include <triqs/hilbert_space/hilbert_space.hpp>
#include <triqs/hilbert_space/state.hpp>
#include <triqs/hilbert_space/imperative_operator.hpp>
#include <triqs/hilbert_space/space_partition.hpp>

using namespace triqs::operators;
using namespace triqs::hilbert_space;
using namespace std;

int main() {

  // Model system: half-filled Hubbard dimer

  // Parameters
  double U  = 2.0;   // Coulomb repulsion
  double mu = U / 2; // Chemical potential
  double t  = 0.2;   // Hopping amplitude

  // Set of fundamental operators
  // Every fundamental operator carries two indices, one atom index and one spin projection
  fundamental_operator_set fops;
  fops.insert(1, "up");
  fops.insert(1, "down");
  fops.insert(2, "up");
  fops.insert(2, "down");

  // Full Hilbert space of the dimer
  hilbert_space hs(fops);

  // Hamiltonian
  auto H = U * n(1, "up") * n(1, "down") + U * n(2, "up") * n(2, "down");
  H += -mu * (n(1, "up") + n(1, "down") + n(2, "up") + n(2, "down"));

  for (auto s : {"up", "down"}) H += -t * (c_dag(1, s) * c(2, s) + c_dag(2, s) * c(1, s));

  // Imperative form of the Hamiltonian acting on the full Hilbert space
  using full_hs_operator_t = imperative_operator<hilbert_space, double, false>;
  full_hs_operator_t hamiltonian(H, fops);

  // Many-body state in the full Hilbert space
  using state_t = state<hilbert_space, double, true /* using sparse storage */>;
  state_t st(hs);

  // Partition the Hilbert space
  space_partition<state_t, full_hs_operator_t> partition(st, hamiltonian);

  // Preallocate a container for the invariant subspaces of H
  vector<sub_hilbert_space> inv_subspaces;
  for (int n = 0; n < partition.n_subspaces(); ++n) inv_subspaces.emplace_back(n);

  // Fill the subspaces with Fock spaces
  foreach (partition, [&](int s, int spn) { inv_subspaces[spn].add_fock_state(hs.get_fock_state(s)); })
    ;

  // Observables: N_up and N_dn
  auto N_up = n(1, "up") + n(2, "up"), N_down = n(1, "down") + n(2, "down");

  // Subspace connections generated by the observables
  auto N_up_conn   = partition.find_mappings(full_hs_operator_t(N_up, fops));
  auto N_down_conn = partition.find_mappings(full_hs_operator_t(N_down, fops));

  // Imperative versions of N_up and N_down acting between subspaces
  using sub_hs_operator_t = imperative_operator<sub_hilbert_space, double, true>;

  vector<int> N_up_hilbert_map(inv_subspaces.size(), -1);
  for (auto const &conn : N_up_conn) N_up_hilbert_map[conn.first] = conn.second;
  sub_hs_operator_t N_up_op(N_up, fops, N_up_hilbert_map, &inv_subspaces);

  vector<int> N_down_hilbert_map(inv_subspaces.size(), -1);
  for (auto const &conn : N_down_conn) N_down_hilbert_map[conn.first] = conn.second;
  sub_hs_operator_t N_down_op(N_down, fops, N_down_hilbert_map, &inv_subspaces);

  // Calculate and print expectation values of N_up and N_down
  for (int spn = 0; spn < inv_subspaces.size(); ++spn) {
    // Iterate over invariant subspaces
    auto const &subspace = inv_subspaces[spn];
    cout << "Invariant subspace " << spn << endl;
    cout << "====================" << endl;
    cout << "State    N_up   N_dn" << endl;
    cout << "====================" << endl;

    // Iterate over basis Fock states in the selected subspace
    for (int i = 0; i < subspace.size(); ++i) {

      // Many-body state defined on the subspace
      state<sub_hilbert_space, double, false> ket(subspace);
      ket(i) = 1;

      cout << "|" << bitset<4>(subspace.get_fock_state(i)) << ">   ";
      cout << ((N_up_hilbert_map[spn] != -1) ? dot_product(ket, N_up_op(ket)) : 0) << "      ";
      cout << ((N_down_hilbert_map[spn] != -1) ? dot_product(ket, N_down_op(ket)) : 0) << endl;
    }
  }

  return 0;
}
